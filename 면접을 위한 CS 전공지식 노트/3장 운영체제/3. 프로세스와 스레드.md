# 프로세스와 스레드
프로세스는 컴퓨터에서 실행되고 있는 프로그램. CPU 스케줄링의 대상이 되는 작업(task) 용어와 같은 의미로 사용.

스레드는 프로세스 내 작업의 흐름.

메모리에 프로그램이 올라가면 프로세스가 되는 인스턴스화가 일어남.

## 1. 프로세스와 컴파일 과정
프로세스는 프로그램이 메모리에 올라가 인스턴스화 된것.

컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 변역해 실행할 수 있는 파일을 만듬.

- c 언어 컴파일 과정

소스코드 파일 -> 전처리 -> 컴파일러 -> 어셈블리어 -> 어셈블러 -> object 코드 + (라이브러리) -> 링커 -> 실행가능 파일

### 전처리
소스코드 주석 제거, #include 등 헤더 파일 병합, 메크로 치환

### 컴파일러
오류 처리, 코드 최적화 작업, 어셈블리어로 변환

### 어셈블러
어셈블리어는 object code로 변환. 확장자는 .o로 만들어짐.

### 링커
프로그램 내의 라이브러리 함수 또는 다른파일들과 object code를 결합해서 실행파일을 만든다. 확장자는 .exe .out

#### 정적 라이브러리, 동적 라이브러리
정적 라이브러리는 프로그램 빌드 할 떄 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는다. 외부 의존도가 낮은 장점. 코드 중복 등 메모리 효율성이 낮은 단점.

동적 라이브러리는 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조한다. 메모리 효율적 장점. 외부 의존도가 높아지는 단점.

## 2. 프로세스의 상태
### 생성 상태
create.
프로세스가 생성된 상태. fork(), exec() 함수를 통해 생성한다.
이때 PCB가 할당된다.

#### fork()
부모 프로세스의 주소 공간을 그대로 복사. 새로운 자식 프로세스를 생성하는 함수. 주소 공간만 복사함. 부모 프로세스의 비동기 작업 등을 상속하진 않음.

#### exec()
새롭게 프로세스를 생성하는 함수.

### 대기 상태
ready.
메모리 공간이 충분하면 메모리를 할당받고 아니면 그냥 대기.
CPU 스케줄러로부터 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태
ready suspended.
메모리 부족으로 일시중단 상태.

### 실행 상태
running.
CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태.

### 중단 상태
blocked.
이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태.
I/O 디바이스에 의한 인터럽트가 대표적.

### 일시중단 상태
blocked suspended.
대기 중단과 유사함. 중단된 상태에서 프로세스가 실행되려 했지만 메모리 부족으로 일시 중단 상태.

### 종료 상태
terminated.
메모리, CPU 소유권을 모두 놓고가는 상태. 자연스러운 종료도 있지만 부모 프로세스에서 자식 프로세스를 강제시키는 비자발적 종료(abort)도 있다. 

## 3. 프로세스의 메모리 구조
동적 영역(스택, 힙), 정적 영역(데이터 영역, 코드 영역)

### 스택과 힙
동적 할당 된다. 런타임 단계에서 메모리를 할당 받는 것.

스택은 지역 변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역. 함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택 영역에 계속 저장된다.
재귀 함수 호출 될 때 새로운 스택 프레임이 생성되어 해당 함수 끼리 간섭 영향이 없다.

힙은 동적으로 할당되는 변수. malloc(), free() 함수를 통해 관리할 수 있다. 동적으로 관리되는 자료 구조는 힙 영역을 사용한다. vector같은 경우 내부적으로 힙을 사용함.

### 데이터 영역과 코드 영역
정적으로 할당되는 영역. 컴파일 단계에서 메모리를 할당하는 것.
데이터 영역은 BSS segment, Data segment, code/text segment로 나뉘어서 저장된다.

BSS segment는 전역 변수 또는 static, const로 선언되어 있고 0으로 초기화 또는 초기화가 안된 변수들이 여기 할당된다.

Data segment는 전역 변수 또는 static, const로 선언되어 있고 0이 아닌 값으로 초기화된 변수들이 여기 할당된다.

code segment는 프로그램의 코드가 들어간다.

## 4. PCB
Process Control Block.
운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'이다.
프로세스가 생성되면 운영체제는 PCB를 만든다. 중요정보여서 커널 스택의 가장 앞부분에서 관리함.

### PCB의 구조
- 프로세스 스케줄링 상태 : '준비', '일시중단' 등 프로세스가 CPU 소유권 얻은 이후 상태
- 프로세스 ID : 프로세스 ID, 해당 프로세스 자식 ID
- 프로세스 권한 : 컴퓨터 자원, I/O디바이스 권한 정보
- 프로그램 카운터 : 다음 실행 명령어 주소 포인터
- CPU 레지스터 : 프로세스 실행하기위해 저장할 레지스터 정보
- CPU 스케줄링 정보 : 스케줄러에 의해 중단된 시간 등의 정보
- 계정 정보 : CPU 사용량, 실행한 유저 정보
- I/O 상태 정보 : 할당된 I/O디바이스 목록

### 컨텍스트 스위칭
PCB를 교환하는 과정. 동시에 여러가지 프로세스를 작업하는 것은 컨텍스트 스위칭이 아주 빠르게 일어나고 있음.

컨텍스트 스위칭이 일어나면 A가 동작할때 B가 쉬는시간, 유휴 시간(idle time),이 발생한다. 그리고 캐시미스도 발생한다.

#### 비용 : 캐시미스
컨텍스트 스위칭이 일어날 때 프로세스가 가진 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생긴다. 캐시클리어 과정 때문에 캐시미스가 발생한다.

#### 스레드에서의 컨텍스트 스위칭
스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 컨텍스트 스위칭의 경우 비용이 더 적고 시간도 적게 걸린다.

## 5. 멀티프로세싱
동시에 두 가지 이상의 일을 수행할 수 있다. 프로세스 일부 문제 생겨도 다른 프로세스를 이용하면 되어서 신뢰성이 높음.

### 웹 브라우저
멀티프로세스 구조를 가진다.
- 브라우저 프로세스
- 렌더러 프로세스
- 플러그인 프로세스
- GPU 프로세스

### IPC
IPC(Inter Process Communication). 멀티프로세스는 IPC가 가능. 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘.

메모리가 완전히 공유되는 스레드보다 속도 떨어짐.

공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐 등이 있다.

#### 익명 파이프
FIFO 방식으로 읽히는 임시 공간을 만들어 단방향 읽기, 쓰기 전용 파이프로 작동. 부모, 자식 프로세스 간에만 사용할 수 있다.

#### 명명된 파이프
파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신.

#### 메시지 큐
커널의 전역변수 형태 등 커널에서 전역적으로 관리. 쓰기, 읽기 빈도가 높아지면 공유메모리 대안으로 메시지 큐 사용

## 6. 스레드와 멀티스레딩
### 스레드
프로세스의 실행가능한 가장 작은 단위. 프로세스는 여러 스레드를 가질 수 있다.

프로세스는 각각 생성하지만 스레드는 코드, 데이터, 힙은 스레드끼리 공유한다. 스택이나 그 외는 각각 생성.

### 멀티스레딩
프로세스 내 작업을 여러 개의 스레드로 처리하는 기법. 자원 공유로 효율성이 높음.

#### 웹 브라우저의 렌더러 프로세스를 이루는 스레드
- 메인 스레드
- 워커 스레드
- 컴포지터 스레드
- 레스터 스레드

## 7. 공유자원과 임계영역
### 공유자원
시스템 안에서 프로세스와 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미한다.
이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)이라 한다. 접근 시간이나 순서에 따라 결과에 영향을 줄 수 있는 상태.

### 임계영역
critical section. 둘 이상의 프로세스나 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역.

해결 방법은 크게 뮤텍스, 세마포어, 모니터 세가지가 있다. 모두 상호 배제, 한정 대기, 융통성이란 조건을 만족한다. LOCK이 주요 메커니즘.

> - 상호 배제
> 
> 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
> - 한정 대기
>
> 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.
> - 융통성
>
> 한 프로세스가 다른 프로세스의 일을 방해해서는 안된다.

#### 뮤텍스
공유자원을 lock()을 통해 잠금 설정하고 사용한 뒤 unlock()하는 객체. 뮤텍스는 잠금 또는 해제의 상태만을 가진다.

#### 세마포어
일반화된 뮤텍스. 간단한 정수 값과 두가지 함수 wait() P함수, signal() V함수로 공유 자원 접근 처리.

wait()는 자신의 차례가 올때까지 기다리는 함수.
signal()은 다음 프로세스로 순서를 넘겨주는 함수.

##### 바이너리 세마포어
0과 1의 값만 가질 수 있는 세마포어. 뮤텍스와 유사함. 뮤텍스는 '잠금 메커니즘', 세마포어는 '신호 메커니즘'.

##### 카운팅 세마포어
여러 개의 값을 가질 수 있는 세마포어. 여러 자원에 대한 접근 제어.

#### 모니터
둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근 할 수 있도록 공유자원을 숨기고 인터페이스만 제공.

모니터 큐를 이용해 작업을 순차적으로 처리한다. 세마포어보다 구현하기 쉽다. 여기는 상호배제 자동. 세마포어는 명시적으로 구현해야함.

## 8. 교착 상태
dead lock. 두 개 이상의 프로세스가 서로가 가진 자원을 기다리며 중단된 상태.

### 교착 상태 원인
- 상호 배제 : 한 프로세스가 자원 독점. 다른 프로세스 접근 불가능.
- 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청.
- 비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없음.
- 환형 대기 : A -> B 요구, B -> A 요구 서로의 자원을 요구.

### 교착 상태의 해결 방법
1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계.
2. 교착 생태 가능성이 없을 때만 자원 할당됨. 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 '은행원 알고리즘'을 사용.
3. 교착 상태가 발생하면 사이클이 있는지 찾아 관련 프로세스 하나씩 지움.
4. 교착 상태는 매우 드물다. 지금은 사용자가 직접 프로세스 종료하는 방법을 사용한다

> 은행원 알고리즘
>
> 총 자원과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘.