# 인덱스

## 1. 인덱스의 필요성
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

## 2. B-트리
인덱스는 보통 B-트리 자료구조로 이루어져있다.
루트 노드, 리프 노드, 그리고 루트노드와 리프노드 사이에 있는 브랜치 노드로 나뉜다.

### 인덱스가 효율적인 이유와 대수확장성
효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.

대수확장성이란 트리 깊이가 리프노드 수에 비해 매우 느리게 성장하는 것을 의미. 기본적으로 인덱스가 한 깊이씩 증가 할 때마다 최대 인덱스 항목은 4배 증가한다.

깊이 10인 트리로 100만개 레코드를 검색할 수 있다.

## 3. 인덱스를 만드는 방법
DBMS마다 다르다.

### MySQL
클러스터형 인덱스와 세컨더리 인덱스가 있음.

클러스터형 인덱스는 테이블당 1개 설정 가능함. primary key 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.

create index ... 명령어를 사용하면 세컨더리 인덱스 생성.
세컨더리 인덱스는 보조 인덱스. 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야하는 인덱스.

클러스터형 인덱스가 성능이 더 좋음.

### MongoDB
도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다. 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

## 4. 인덱스 최적화 기법
데이터베이스마다 조금씩 다르지만 기본적인 골조는 같다.
아래는 MongoDB기반의 최적화기법이다.

### 1. 인덱스는 비용이다
인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트 => 컬렉션 순으로 탐색한다.

컬렉션이 수정되었을 때 인덱스도 수정되어야한다. 이때 B-트리의 높이를 균형있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 든다.

쿼리에 있는 필드에 전부 인덱스를 생성하는 것은 답이 아니다. 컬렉션에서 가져와야하는 양이 많을 수록 인덱스를 사용하는게 비효율적이다.

### 2. 항상 테스팅해라
최적화 기법은 서비스에 따라 달라진다. explain() 함수를 통해 인덱스를 만들고 테스트를 하며 걸리는 시간을 최소화 해야한다.

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때 순서가 있음. 생성 순서에 따라 성능이 달라짐.

같음, 정렬, 다중 값, 카디널리티 순서

1. ==, equal 이런 쿼리가 있으면 제일먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 그다음 인덱스 설정
3. 다중 값을 출력해야하는 필드, 즉 쿼리가 >, < 등 많은 값을 출력하는 경우
4. 유니크한 값의 정도를 카디널리티라고 한다. 카디널리티가 높은 순서로 인덱스를 설정해야함. age와 email이 있으면 email이 카디널리티가 높음.