# 선형 자료 구조
요소가 일렬로 나열되어 있는 자료 구조

## 1. 연결 리스트
노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조. 삽입과 삭제가 $O(1)$이고 탐색은 $O(n)$이 걸린다.

prev포인터와 next포인터로 앞과 뒤의 노드를 연결시킨 것이 연결리스트. 연결리스트 종류에는 싱글연결리스트, 이중연결리스트, 원형연결리스트가 있다.

c++의 list는 double linked list로 구현되어있다.

## 2. 배열
array는 같은 타입의 변수들로 이루어져있고, 크기가 정해져있고, 인접한 메모리위치에 있는 데이터를 모아놓음. 중복 허용, 순서있음.

탐색 $O(1)$ 랜덤접근이 가능. 삽입, 삭제는 $O(n)$ 걸린다. 따라서 삽입, 삭제 많은거는 연결리스트, 탐색 많이하는거는 배열로 하는 것이 좋다.

### 랜덤 접근과 순차적 접근
랜덤 접근은 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능. 순차적 접근은 저장된 순서대로 검색하는 것.

### 배열과 연결리스트 비교
연결리스트는 head로 부터 순서대로 탐색을 해야하기 때문에 탐색이 느리다. 삽입 삭제는 연결리스트는 중간에 넣고 prev와 next를 연결해주면 되지만 배열은 중간에 삽입, 삭제하면 데이터를 옮기는 비용이 발생한다.

## 3. 벡터
vector는 동적으로 요소를 할당할 수 있는 동적 배열이다.
컴파일 시점에 개수를 모르는 경우 vector를 사용해야함.
탐색과 맨앞, 맨뒤에 삽입 삭제는 $O(1)$이 걸린다. 맨앞, 맨뒤에 삽입 삭제가 아닌 경우 $O(n)$이 걸린다.

push_back()을 할때 $O(1)$시간이 걸리는데, 벡터의 크기가 증가하는 시간 복잡도가 $O(1)$과 유사한 시간 복잡도를 가지기 때문이다.

push_back()을 한다고 매번 크기가 증가하는 것이 아니라 $2^n+1$마다 크기를 2배 늘린다.

vector는 push_back(), pop_back(), erase(), find(), clear()등의 함수가 있음.

## 4. 스택
스택은 가장 마지막으로 들어간 데이터가 먼저 나오는 성질(LIFO, Last In First Out)을 가진 자료구조. 재귀함수, 알고리즘에 사용됨. 웹 브라우저 방문 기록 등에 쓰인다. 삽입, 삭제에 $O(1)$ 탐색에 $O(n)$이 걸린다. push()와 pop()으로 데이터를 제어한다.

```C++
stack<int> stk;
int main(){
    stk.push(1);
    cout << stk.top() << "\n";
    stk.pop();
}
```

## 5. 큐
큐는 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 가진 자료구조. 삽입, 삭제에 $O(1)$ 탐색에 $O(n)$이 걸린다.

```C++
int main(){
    queue<int> q;
    q.push(1);
    cout << q.front() << "\n";
    q.pop();
}
```