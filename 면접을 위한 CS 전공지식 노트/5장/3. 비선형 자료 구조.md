# 비선형 자료 구조

## 1. 그래프
정점과 간선으로 이루어진 자료 구조

### 정점과 간선
정점(vertex), 간선(edge). 단방향 그래프, 양방향 그래프.
나가는 간선 outdegree, 들어오는 간선 indegree.

#### 가중치
간선과 정점 사이에 드는 비용. A -> B로 가는 비용

## 2. 트리
그래프의 종류 중 하나. 루트 노드, 내부 노드, 리프 노드 등으로 구성된다.

### 트리의 특징
1. 부모, 자식 계층 구조를 가진다.
2. V-1=E라는 특징이 있다. 간선수 = 노드수 - 1
3. 임의의 두 노드 사이의 경로는 유일하게 존재한다.

### 트리의 구성
루트 노드, 내부 노드, 리프 노드

### 루트 노드
가장 최상단의 노드.

### 내부 노드
루트 노드와 리프노드 사이의 노드

### 리프 노드
자식노드가 없는 노드

#### 트리의 높이와 레벨
- 깊이: 트리에서의 깊이는 루트 노드로 부터 특정 노드까지의 최단거리
- 높이: 루트 노드부터 리프 노드까지의 거리 중 가장 긴 거리
- 레벨: 보통 깊이와 같은 의미를 가진다. 루트 노드를 0레벨로 할껀지, 1레벨로 할껀지에 따라 하위 노드의 레벨이 바뀐다.
- 서브트리: 트리 내의 하위 집합을 서브트리라고 한다.

### 이진트리
이진 트리는 자식 노드의 수가 2개 이하인 트리
- 정이진 트리(full binary tree): 자식 노드가 0 또는 2개인 이진 트리
- 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져있는 이진 트리. 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있어야함. 마지막 레벨은 왼쪽부터 채워져 있음.
- 변질 이진 트리(degenerate binary tree): 자식 노드가 하나 밖에 없는 이진 트리
- 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차있는 이진 트리
- 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진 트리. map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나이다.

### 이진 탐색 트리
BST는 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고 왼쪽 하위 트리에는 '노드 값보다 작은 값'만 있는 트리. 이렇게 만들면 '탐색'에 용이하다. 이진 탐색의 경우 보통 $O(\log n)$이 걸린다. 최악의 경우 $O(n)$

### AVL 트리
AVL 트리(Adelson-Velsky and Landis tree)는 이진 탐색 트리에서 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 트리. 두 자식 서브트리의 높이의 차이가 항상 최대 1만큼 차이난다.

AVL트리는 탐색, 삽입, 삭제 모두 $O(\log n)$

### 레드 블랙 트리
균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 $O(\log n)$. 각 노드는 빨간색 또는 검은색의 색을 나타내는 추가 bit를 저장. 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는데 사용한다. C++ STL의 set, multiset, map, multimap이 레드 블랙 트리로 구현되어있다.

"모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다." 규칙을 기반

## 3. 힙
힙은 완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리.
- 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최대값. 각 노드의 자식 노드와의 관계도 이를 지켜야함.
- 최소힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최소값. 각 노드의 자식 노드와의 관계도 이를 지켜야함.

### 최대힙의 삽입
힙에 새로운 요소가 들어오면 힙의 마지막 노드에 이어서 삽입한다. 이를 부모 노드의 크기와 비교하며 교환해서 힙의 성질을 만족시킨다.

### 최대힙의 삭제
최대힙의 최대값은 루트노드이므로 루트노드가 삭제된다. 이후 마지막 노드와 루트노드를 swap하고 이후 자식노드와 계속 비교하며 최대힙의 규칙을 만족하도록 만든다.

## 4. 우선순위 큐
대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료구조. 우선순위 큐는 힙을 기반으로 만들어진다.
```C++
priority_queue<int, vector<int>, greater<int>> pq // 오름차순
priority_queue<int, vector<int>, less<int>> pq // 내림차순
```

## 5. 맵
c++의 map은 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료구조. 레드 블랙 트리 자료 구조를 기반으로 형성됨.

map<string, int> 형태로 구현한다.

map은 해시 테이블을 구성할 때 사용하며, 정렬을 보장하지 않은 unordered_map과 정렬을 보장하는 map이 있다.

```c++
int main(){
    unordered_map<string, int> umap;
    // 전부 넣는 방법
    umap.insert({"test1", 1});
    umap.emplace("test5", 5);
    umap["test1"] = 4; // 이거를 추천. 이걸로 변경, 추가 가능
}
```

## 6. 셋
set은 중복되는 요소가 없는 unique값만 저장하는 자료구조.

unordered_set은 정렬없음. set은 정렬있음.

```c++
int main(){
    set<pair<int, int>> _set;
    _set.insert({"test", 1});
}
```
pair은 2가지 형을 담을 수 있는 구조.

## 7. 해시 테이블
해시 테이블은 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블이다. 삽입, 삭제, 탐색 시 평균적으로 $O(1)$의 시간 복잡도를 가진다. unordered_map으로 구현한다.