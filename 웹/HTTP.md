## HTTP

### HTTP/1.1
HTTP는 웹에서 클라이언트와 서버 간의 통신 프로토콜이다. HTTP/1.0은 한 개의 요청과 응답마다 TCP 커넥션을 생성해서 사용했다. 근데 이러면 요청마다 연결을 해야하는 오버헤드가 발생한다. 

그래서 HTTP/1.1은 지속 커넥션(Persistent Connection)이라는 지정한 타임아웃만큼 커넥션을 유지하는 방식으로 해결.

파이프라이닝(Pipelining)을 지원해서 요청의 응답지연을 감소한다. 기존에는 요청한 이후에 응답을 기다리고 다음 요청을 보냈는데, 파이프라이닝은 필요한 요청 전부를 순차적으로 전송하고 모든 응답을 한 번에 기다린다.

문제점 - Head-of-Line Blocking(HOL Blocking)

3개의 요청을 파이프라인을 통해 전송했을때, 서버는 모든 요청을 순서에 맞게 응답해야한다. 이때 첫번째 요청이 오래걸리면 나머지 요청은 대기해야한다.

요청마다 동일한 헤더를 반복해서 전송하는 문제점도 있다.

### HTTP/2.0
HTTP/1.1에서는 메시지를 일반 텍스트형식으로 전송. 2.0은 기존 메시지를 '프레임'이라는 단위로 분할하고 바이너리 형태로 전송한다. 파싱과 전송속도 향상.

멀티플렉싱(Multiplexing) 지원. 하나의 커넥션을 사용해서 요청과 응답을 병렬로 처리하는 방식. 클라이언트가 서버로 여러 요청을 보내도 독립적으로 처리되어서 HOL Blocking을 해결한다. 

HPACK 헤더 압축 방식을 사용해서 반복적으로 보내는 헤더를 효율적으로 관리.

문제점 - TCP위에서 동작하기 때문에 TCP가 가진 한계를 벗어날 수 없다. TCP의 느린 연결 수립, TCP레벨에서의 HOL Blocking


### HTTP/3
UDP를 사용한다. QUIC이라는 프로토콜 위에 설계되었다.

#### QUIC
1. 빠른 연결 수립 (built-in security)

기존TCP는 기본 연결 후 TLS 연결을 진행해서 최소 2회의 RTT가 발생한다. QUIC는 1RTT만에 연결과 보안을 동시에 진행한다.

2. HOLB 문제가 해결된 멀티플렉싱

이전에는 패킷이 손실되면, 손실된 패킷이 재전송되기 전까지는 전체 데이터 전송의 흐름에 병목이 생길 수 밖에 없었다.

QUIC는 패킷이 가지고 있는 byte stream에 대하여 stream id를 부여. stream id 덕분에 패킷들은 독립적인 패킷이 된다.

3. Connection ID

connection id. ip주소나 여타 다른 이유에 의해서 네트워크 인터페이스가 변경되더라도 생성했었던 연결을 유지할 수 있게 해주는 기능. wifi -> 데이터 연결로 변경했을 때 TCP는 다시 연결해야함.

Connection ID는 패킷 헤더에 붙어 있다. 전송계층 아래의 단계(TCP, IP 등등) 에서 변경사항이 생겨도, 전송되는 패킷이 잘못된 end point로 전달되지 않도록 보장.

4. UDP의 단점을 보완한 QUIC

UDP에는 크게 2가지의 문제점 신뢰성과 보안의 문제. 손실되어도 그것에 대해 책임을 지지 않는다는 점, 그리고 암호화 기능이 없어 중간에 데이터를 탈취하거나 변조하는 공격에 취약하다는 점이 UDP의 주요 문제점.

신뢰성은 멀티플랙싱을 도입하면서 ID를 주어 재전송 가능하게 만듬.

보안은 QUIC는 전송계층에서 암호화를 통합해서 해결했다.
