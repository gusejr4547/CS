## DB 스토리지 엔진
스토리지 엔진은 DBMS에서 데이터를 저장하고 관리하는 핵심 구성요소입니다.

### 역할
스토리지 엔진에 따라 제공하는 기능이 다릅니다.
1. 데이터 저장 방식 결정
2. 데이터 읽기 쓰기 성능 최적화
3. 트랜젝션 지원 여부
4. 동시성 제어
5. 데이터 무결성 보장

### MySQL
MySQL의 기본 DB 스토리지 엔진은 InnoDB입니다.

1. InnoDB
- MySQL의 기본 스토리지 엔진
- 트랜잭션 지원 (ACID 준수)
- 외래 키(Foreign Key) 지원
- MVCC(다중 버전 동시성 제어) 지원
- Crash Recovery(충돌 복구) 기능 내장
- 높은 동시성을 제공하여 OLTP(Online Transaction Processing)에 적합
  
2. MyISAM
- 트랜잭션 미지원 (ACID 미준수)
- 빠른 읽기 성능을 제공하여 검색이 많은 환경(읽기 집중형)에 적합
- 외래 키 미지원
- 테이블 수준의 잠금(Locking) 방식 사용

## 트랜잭션 격리수준

동시에 여러 트랜잭션이 실행될 때 한 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않도록 하는 정도를 나타낸다.

낮은 격리수준은 동시성을 높이지만, 데이터의 일관성에 문제가 발생할 수 있다.

높은 격리수준은 데이터의 일관성을 보장하지만, 동시성이 낮아진다.

### 종류
- READ UNCOMMITTED
  
  커밋이 되지 않은 데이터 변경 내용도 다른 트랜잭션이 읽을 수 있음. dirty read, phantom read, non-repeatable read 발생할 수 있다.

- READ COMMITTED
  
  커밋이 완료된 트랜잭션의 변경내용만 다른 트랜잭션이 조회 할 수 있다. 트랜잭션이 이루어지는 데이터는 접근이 불가능.
  phantom read, non-repeatable read 발생할 수 있다.

- REPEATABLE READ
  
  한 트랜잭션이 특정 레코드를 조회할 때 항상 같은 데이터를 반환하는 것을 보장. phantom read 발생할 수 있다.

- SERIALIZABLE
  
  트랜잭션이 사용중인 테이블 전체를 다른 트랜잭션이 접근 못하게 함. 테이블에 Lock이 걸리기 때문에 동시성이 가장 낮음.

### 격리수준에 따라 발생하는 문제

- Dirty Read
  
  한 트랜잭션이 다른 트랜잭션이 변경 중인 데이터를 읽는 경우 발생한다. 커밋되지 않은 데이터를 읽었기 때문에 롤백될 경우 서로 다른 값을 가지게 될 가능성이 있다.

- Non-repeatable Read
  
  같은 트랜잭션 안에서 같은 쿼리를 실행했을때 서로 다른 결과를 얻는 경우. 첫번째 쿼리와 두번째 쿼리 사이에 다른 트랜잭션이 값을 변경한 경우 발생.

- Phantom Read
  
  한 트랜잭션이 동일한 쿼리를 두 번 실행했을 때, 사이에 다른 트랜잭션이 Insert, Update, Delete 작업을 수행해 결과 집합이 달라지는 경우.


## 데이터베이스의 특징에 대해 설명해주세요
1. 실시간 접근성(Real-Time Accessibility) : 수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다.

2. 계속적인 변화(Continuous Evolution) : 데이터베이스의 상태는 동적이다. 즉 새로운 데이터의 삽입(Insert),삭제(Delete),갱신(Update)로 항상 최신의 데이터를 유지한다.

3. 동시공용(Concurrent Sharing): 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.

4. 내용에 의한 참조(Content Reference): 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터를 찾는다.

## 트랜잭션 정의와 특징에 대해 설명해주세요
트랜잭션은 DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위.

특징 ACID - 원자성, 일관성, 독립성, 지속성

- 원자성
  
  트랜잭션이 실행되면 결과는 반영되거나 반영되지 않아야한다.

- 일관성
  
  데이터베이스를 구성할 때에 정해놓은 규칙들(일관성)은 트랜잭션을 성공하고 나서도 계속해서 유지되어야 한다.
  트랜잭션의은 '허용된 방식'으로만 데이터를 변경해야 한다. 데이터 조건, 규칙에 유효해야한다. 

- 독립성, 격리성
  
  두 개 이상의 트랜잭션이 동시에 실행될때 서로 연산에 끼어들 수 없다.

- 지속성
  
  트랜잭션이 성공적으로 완료되면 영구적으로 반영되어야한다. 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 한다.

## NoSQL이란 무엇인가요?
Not only SQL 이라는 슬로건에서 생겨난 데이터베이스. SQL을 사용하지 않는 데이터베이스이고, 대표적으로 MongoDB, redis 등이 있다.

### 특징
- 반정형(명확한 스키마 없음, 일정 수준의 자유도 허용, NoSQL/JSON 형태의 데이터)/비정형(스키마 없음, 비디오/오디오 등의 멀티미디어 데이터) 데이터에 적합
- ACID 대신 Eventual Consistency(궁극적 일관성): Consistency를 조금 타협하고 꼭 실제 최신은 아닐 수 있지만 업데이트가 되기 전까지는 가지고 있는 최신의 데이터를 반환함을 의미 -> 분산형의 특성상 일관성 유지가 어려움
- 대용량/분산형 데이터 저장에 유리
- 특정 도메인의 문제 해결에 좋음: Key-value, Graph 등 자료 형태가 다양해 특정 분야에서 고성능(소셜 네트워크: 인간 관계는 그래프)
- 데이터를 질의하는 API가 다양
- 분산형 컴퓨터에 최적화, 확장성 좋음: 머신의 수를 늘리는 수평적 확장
- NoSQL은 SQL보다 제품 지원이 어려움
- 인력 운영 비용이 더 비쌈: 표준화 부족, 질의 언어 다양

### 종류
- Column-based: 열 별로 연속적으로 저장, 기존 SQL은 테이블에 행 단위로 순차적으로 저장 -> 레코드의 특정 부분만 수정할 때, 필요한 열의 데이터만 로드하면 되서 IO 작업 감소, 한 열에 들어가는 데이터 형식에 일관성이 있어 DB 내의 한 블록은 동일한 유형의 데이터를 보유 -> 데이터의 유형에 맞는 압축 인코딩 가능, 디스크 공간 절약 및 성능 향상 가능
- Document-oriented: JSON 객체로 문서(레코드)를 구성, 다양항 구조로 테이블 구성 가능, MongoDB
- Key-Value: 연관 배열을 데이터 모델로 이용, Key는 한 Collection에 한 번만 등장 가능
- Graph


## 데이터베이스 커넥션 풀을 사용하지 않으면 발생할 수 있는 문제
일단 애플리케이션과 데이터베이스의 연결 과정을 살펴보아야함.

- 데이터베이스 드라이버를 사용해서 데이터베이스에 연결
- 데이터 읽기/쓰기를 위한 TCP 소켓 열기
- 소켓을 통한 데이터 읽기/쓰기
- 연결 종료
- 소켓 닫기

커넥션 풀이 없으면 데이터베이스 접근 요청을 할 떄마다 위의 과정을 반복해야한다. 이 과정은 비용이 상당히 많이 들기 때문에 속도 저하가 발생할 것이다.

그리고 동시에 여러 요청이 들어오는 경우 매번 새로운 커넥션을 생성하는데, 데이터베이스의 최대 연결 수를 초과할 수 있다.

### 커넥션 풀의 장점
애플리케이션과 데이터베이스의 연결을 미리 만들어 두고 재사용하는 방법이다. 매번 연결을 생성하고 종료하는 대신에 미리 만들어 둔것을 사용해서 성능을 향상시키고 자원을 효율적으로 사용할 수 있다.

커넥션 풀의 주요 구성 요소는 초기 풀 크기(Initial Pool Size), 최소 풀 크기(Minimum Pool Size), 최대 풀 크기(Maximum Pool Size), 연결 대기 시간(Connection Timeout) 등이 있고, 이를 통해 커넥션을 효율적으로 관리하고 사용할 수 있다.

### 커넥션 풀의 사이즈가 클 수록 좋을까?
커넥션을 사용하는 주체는 스레드이다. 커넥션 풀과 스레드 풀이 균형을 이루는 것이 좋을 것.

하지만 너무 큰 사이즈로 설정하면 데이터베이스 서버, 애플리케이션 서버의 CPU나 메모리를 과도하게 사용하기 때문에 전체적인 성능이 저하된다.